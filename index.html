<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>STEVE · 3D Holographic Space</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
  }
  #video { display: none; }
  .hud {
    position: absolute;
    top: 20px;
    left: 20px;
    color: #00ffff;
    letter-spacing: 3px;
    opacity: 0.6;
    font-family: Arial;
  }
</style>
</head>

<body>
<div class="hud">STEVE · SPACE CRAFT MODE</div>
<video id="video" autoplay playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
// ================= THREE.JS SCENE =================
const scene = new THREE.Scene();

const camera3D = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera3D.position.z = 6;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setClearColor(0x000008);
document.body.appendChild(renderer.domElement);

// ================= STARFIELD =================
const starsGeo = new THREE.BufferGeometry();
const starsCount = 3000;
const pos = [];

for (let i = 0; i < starsCount; i++) {
  pos.push(
    (Math.random() - 0.5) * 200,
    (Math.random() - 0.5) * 200,
    -Math.random() * 200
  );
}

starsGeo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
const starsMat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.15 });
const stars = new THREE.Points(starsGeo, starsMat);
scene.add(stars);

// ================= HOLOGRAM CUBE =================
const cubeGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
const cubeMat = new THREE.MeshBasicMaterial({
  color: 0x00ffff,
  wireframe: true
});
const cube = new THREE.Mesh(cubeGeo, cubeMat);
scene.add(cube);

// Glow ring
const ringGeo = new THREE.RingGeometry(1.7, 1.9, 64);
const ringMat = new THREE.MeshBasicMaterial({
  color: 0x00ffff,
  side: THREE.DoubleSide
});
const ring = new THREE.Mesh(ringGeo, ringMat);
ring.rotation.x = Math.PI / 2;
scene.add(ring);

// ================= HAND TRACKING =================
const video = document.getElementById("video");
let pinchStrength = 0;

const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(res => {
  if (!res.multiHandLandmarks) return;

  const lm = res.multiHandLandmarks[0];
  const index = lm[8];
  const thumb = lm[4];

  const ix = (index.x - 0.5) * 8;
  const iy = -(index.y - 0.5) * 6;

  cube.position.x = ix;
  cube.position.y = iy;
  ring.position.x = ix;
  ring.position.y = iy;

  const dx = index.x - thumb.x;
  const dy = index.y - thumb.y;
  pinchStrength = Math.sqrt(dx*dx + dy*dy);
});

// ================= CAMERA =================
const cam = new Camera(video, {
  onFrame: async () => await hands.send({ image: video }),
  width: 640,
  height: 480
});
cam.start();

// ================= ANIMATE =================
function animate() {
  requestAnimationFrame(animate);

  cube.rotation.x += 0.01;
  cube.rotation.y += 0.015;

  if (pinchStrength < 0.04) {
    cube.scale.set(1.8, 1.8, 1.8);
    ring.scale.set(1.4, 1.4, 1.4);
  } else {
    cube.scale.set(1, 1, 1);
    ring.scale.set(1, 1, 1);
  }

  stars.rotation.y += 0.0005;
  renderer.render(scene, camera3D);
}

animate();

window.addEventListener("resize", () => {
  camera3D.aspect = window.innerWidth / window.innerHeight;
  camera3D.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
