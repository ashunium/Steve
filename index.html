<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>STEVE · 3D Holographic Space</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
  }
  #video { display: none; }
  .hud {
    position: absolute;
    top: 20px;
    left: 20px;
    color: #00ffff;
    letter-spacing: 3px;
    opacity: 0.6;
    font-family: Arial;
  }
</style>
</head>

<body>
<div class="hud">STEVE · SPACE CRAFT MODE</div>
<video id="video" autoplay playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
  let targetX = 0;
  let targetY = 0;
  let targetZ = 0;

  let smoothX = 0;
  let smoothY = 0;
  let smoothZ = 0;

// ================= THREE.JS SCENE =================
const scene = new THREE.Scene();

const camera3D = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera3D.position.z = 6;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setClearColor(0x000008);
document.body.appendChild(renderer.domElement);

// ================= STARFIELD =================
const starsGeo = new THREE.BufferGeometry();
const starsCount = 3000;
const pos = [];

for (let i = 0; i < starsCount; i++) {
  pos.push(
    (Math.random() - 0.5) * 200,
    (Math.random() - 0.5) * 200,
    -Math.random() * 200
  );
}

starsGeo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
const starsMat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.15 });
const stars = new THREE.Points(starsGeo, starsMat);
scene.add(stars);

// ================= HOLOGRAM CUBE =================
const cubeGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
const cubeMat = new THREE.MeshBasicMaterial({
  color: 0x00ffff,
  wireframe: true
});
const cube = new THREE.Mesh(cubeGeo, cubeMat);
scene.add(cube);

// Glow ring
const ringGeo = new THREE.RingGeometry(1.7, 1.9, 64);
const ringMat = new THREE.MeshBasicMaterial({
  color: 0x00ffff,
  side: THREE.DoubleSide
});
const ring = new THREE.Mesh(ringGeo, ringMat);
ring.rotation.x = Math.PI / 2;
scene.add(ring);

// ================= HAND TRACKING =================
const video = document.getElementById("video");
let pinchStrength = 0;

const hands = new Hands({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(res => {
  if (!res.multiHandLandmarks) return;

  const lm = res.multiHandLandmarks[0];

  const index = lm[8];
  const thumb = lm[4];
  const wrist = lm[0];

  // Normalize to centered space
  targetX = (index.x - 0.5) * 6;
  targetY = -(index.y - 0.5) * 4;

  // Depth using hand size (distance wrist → index)
  const dx = index.x - wrist.x;
  const dy = index.y - wrist.y;
  const handSize = Math.sqrt(dx*dx + dy*dy);

  targetZ = THREE.MathUtils.clamp(
    -handSize * 8,
    -6,
    -2
  );

  // Pinch detection
  const pinchDist = Math.hypot(
    index.x - thumb.x,
    index.y - thumb.y
  );

  cube.userData.pinch = pinchDist < 0.04;
});


// ================= CAMERA =================
const cam = new Camera(video, {
  onFrame: async () => await hands.send({ image: video }),
  width: 640,
  height: 480
});
cam.start();

// ================= ANIMATE =================
function animate() {
  requestAnimationFrame(animate);

  // Smooth movement (THIS IS THE MAGIC)
  smoothX += (targetX - smoothX) * 0.12;
  smoothY += (targetY - smoothY) * 0.12;
  smoothZ += (targetZ - smoothZ) * 0.12;

  cube.position.set(smoothX, smoothY, smoothZ);
  ring.position.set(smoothX, smoothY, smoothZ);

  // Rotation
  cube.rotation.x += 0.008;
  cube.rotation.y += 0.01;

  // Pinch scaling
  if (cube.userData.pinch) {
    cube.scale.set(1.6, 1.6, 1.6);
    ring.scale.set(1.3, 1.3, 1.3);
  } else {
    cube.scale.set(1, 1, 1);
    ring.scale.set(1, 1, 1);
  }

  stars.rotation.y += 0.0004;
  renderer.render(scene, camera3D);
}


animate();

window.addEventListener("resize", () => {
  camera3D.aspect = window.innerWidth / window.innerHeight;
  camera3D.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
